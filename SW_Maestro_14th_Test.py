##### 사전 연습 문제 알고리즘 - 1

import math

def solution(nums):
    
    nums.sort()
    max_sum = sum(nums[-1:-4:-1])
    min_sum = sum(nums[0:3])
    
    prime = [i for i in range(min_sum, max_sum+1)]
    
    for i in range(len(prime)):
        for j in range(2, int(math.sqrt(max_sum))+1):
            if prime[i] != j and prime[i] % j == 0 and prime[i] in prime:
                prime.remove(prime[i])
            else:
                continue
    return prime

nums = [1,2,7,6,4]

print(solution(nums))


##### 사전 연습 문제 SQL - 1



##### 본 테스트 문제 알고리즘 - 1
'''
Level(경사로 단계), Height(적설량)이 LH = [3,1,4,10,1] 등의 형태로 주어진다. 
경사로는 단계별로 (n*2)+1의 눈을 버틸 수 있다.
5단계의 경사로가 주어진다면, 이 경사로는 단계별로 각각 [1,3,5,7,9] 만큼의 눈의 양을 버틸 수 있다.
5단계의 경사로에 [3,1,4,10,1]의 눈이 내린다면, 각 경사 단계가 버틸 수 있는 정도까지 쌓이고 남은 눈은 다음 경사로로 넘어간다.
이 경우 경사로에 쌓인 눈을 출력하라. > [1,3,4,7,4]
'''


##### 본 테스트 문제 알고리즘 - 2
'''
여러 선분들의 시작점, 끝점(x1, y1, x2, y2)으로 이루어진 좌표 정보 N개가 제공된다.
이 선분들이 좌표평면에 놓아졌을 때, 십자 모양을 이루는 경우 십자 모양의 크기 MAX(십자를 이루는 선분의 절반 길이)를 출력하라.
단 십자 모양을 이루는 선분이 다른 선분에 의해 가로막힐 경우(90도), 가로막혀진 지점까지만 십자 모양으로 인정된다.
십자 모양이 없을 경우엔 -1을 출력하라.
'''


##### 본 테스트 문제 알고리즘 - 3
'''
여러 도미노 블록들이 Position(위치), Height(높이) 값을 가지고 주어진다.
Position이 1이고, Height이 3인 도미노 블록[1,3]은 쓰러지면 Position 2,3,4에 있는 블록까지 무너뜨린다.
제거할 수 있는 도미노 블록 수 M이 주어질 때, 가장 위험한 블록 M개를 뺀 후에도 무너지게 되는 최소한의 블록 개수를 출력하라.
'''


##### 본 테스트 문제 알고리즘 - 4
'''
# 손님의 수와 젓가락 짝이 리스트 = [AA, BC, BD, CD] 등의 형태로 주어진다.
# 손님은 자기 바로 옆 손님과 젓가락 하나만을 교환할 수 있을 때, 
# 모두가 짝이 맞는 젓가락을 가지기 위해 해야하는 최소 교환 횟수 N을 출력하라.
'''


##### 본 테스트 문제 SQL - 1
'''
테이블 A에서 고객의 ID 컬럼을 출력해야한다.
고객의 ID 정보는 영문+숫자 조합으로 이루어져 있는데 ( ex. myid23, new007 )
이를 영문+숫자4자리 형태로 통일시켜야 한다. ( ex. myid0023, new0007)
숫자 앞에 0을 붙여 형태를 통일한 뒤 ID 컬럼을 출력하라.
'''

